#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf
#define false	0
#define true	1

#include <stdio.h>
#include <malloc.h>

//---------------------------------------------------------------------------//
/*
				Лабораторная работа № 17
учебной группы 61391
Волкова А.А.
Дата выполнения: 08.12.2018
Тема работы: «Разработка, отладка и испытание алгоритмов и программ основанных на поиске в ширину и глубину в графе».
Задание: Найти длину самого длинного простого пути от города А до города В в
заданной системе односторонних дорог.
*/
//---------------------------------------------------------------------------//

// Структура, необходимая только для запаминания маршрута
typedef struct Town{
	int from;
	int value;
} Town;

int    townsCount; // количство вершин
int*   matrix;     // матрица смежности
Town*  towns;      // массив, хранящий пути до каждой вершины

// Функция заполнение исходных данных
void   fillTowns();
// Функция находжения самого длинного пути 
void   findWay(int текущий_город, int конечный_пункт, _Bool* посещённые_города, int вес_пути_до_города);
// Возвращает ссылку на копию исходного массива
_Bool* copy(_Bool* исходный_массив);
// Выводит самый длинный маршрут
void   printWay(int начало_пути, int конец_пути);

void main() {
	// Добавление кириллицы в консоль
	setlocale(0, "Russian");
	int from, to; // Переменные для хранения индексов городов, между которыми будет находится самый длинный путь
	// Ввод исходных данных
	fillTowns();
	// Ввод индексов городов, между которыми будет находится самый длинный путь
	printf("\n\nВведите пункт отправления:\n");
	scanf("%d", &from);
	printf("Введите конечный пункт:\n");
	scanf("%d", &to);
	// Заполнение массива towns. Изначально все города являются непосещёнными
	findWay(from, to, (_Bool[]) { 0, 0, 0, 0, 0 } , 0);
	// Вывод результата
	printWay(from, to);
	getch();

}
// Функция заполнение исходных данных
void fillTowns() {
	printf("Введите количество городов:\n");
	scanf("%d", &townsCount);
	// Выделение памяти под матрицу смежности
	matrix = malloc(sizeof(int) * townsCount * townsCount);
	// Заполнение матрицы смежности
	for (int y = 0; y < townsCount; y++) {
		// Заполние всех ячейкеек нулями
		for (int x = 0; x < townsCount; x++) {
			matrix[y * townsCount + x] = 0;
		}
		// Считываем вес рёбер с клавиатуры
		printf("Из города %d можно попасть в город:\n", y);
		char* string = malloc(sizeof(char) * townsCount);
		scanf("%s", string);
		// Перевод строчки "274" в цифры 2, 7, 4 и вставка в соответствующие ячейки единиц
		do {
			int x = (int)*string - 48;
			matrix[y * townsCount + x] = 1;
		} while (*(++string) != '\0');
	}
	// Выделение памяти под массив, где будет хранится информация о путях до каждой из вершин
	towns = malloc(sizeof(Town) * townsCount);
	// Заполнение массива
	for (int i = 0; i < townsCount; i++) {
		// Это значит, что стоимость пути из исходного города в город с индексом i равна 0,
		// а добраться можно через город -1
		towns[i] = (Town) { -1, 0 };
	}
	// Вывод матрицы смежности
	printf("Матрица смежности:\n\n ");
	for (int y = 0; y < townsCount; y++) {
		printf("  %d", y);
	}
	printf("\n  ");
	for (int y = 0; y < townsCount; y++) {
		printf("---", y);
	}
	for (int y = 0; y < townsCount; y++) {
		printf("\n %d|", y);
		for (int x = 0; x < townsCount; x++) {
			printf("%d  ", matrix[y * townsCount + x]);
		}
	}
}
// Возвращает ссылку на копию исходного массива
_Bool* copy(_Bool* parent) {
	_Bool* c = malloc(townsCount);
	for (int i = 0; i < townsCount; i++)
		c[i] = parent[i];
	return c;
}
// Функция находжения самого длинного пути 
void findWay(int from, int to, _Bool* visited, int value) {
	// Помечение вершины как посещённой
	visited[from] = true;
	// Обход всех вершин
	for (int i = 0; i < townsCount; i++) {
		// Если имеется связь с текущей вершиной и вершина ещё не посещялась
		if (matrix[from * townsCount + i] && !visited[i]) {
			// то увеличиваем длину пути на вес ребра
			value += matrix[from * townsCount + i];
			// Если данный путь длиннее, чем все предыдущие
			if (towns[i].value < value) {
				// то обновляем информацию о вершине 
				towns[i].value = value;
				towns[i].from = from;
				// Если не достигнута конечная вершина
				if (to != i)
				// то происходит вызов рекурсии
				findWay(i, to, copy(visited), value);
			}
			// Возврат исходного значения
			value -= matrix[from * townsCount + i];
		}
	}
}
// Выводит самый длинный маршрут
void printWay(int from, int to) {
	printf("\nСамый длинный маршрут из города %d в город %d:\n", from, to);
	do {
		printf("%d<= ", to);
		to = towns[to].from;
	} while (towns[to].value);
	printf("%d", to);
}

/*---------------------------------------------------------------------------//
В данной программе применяется алгоритм расчёта максимального расстояния 
между вершинами графа. Автором алгоритма является Волков А.А. 
Все права защищены. Любое несанкционированное использование алгоритма 
в коммерческих целях карается законом РБ. Берегите себя и своих близких.

© А.А. Волков, 2018
//---------------------------------------------------------------------------*/