#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf
#define TOWNS   13
#define true	1

#include <stdio.h>
#include <malloc.h>

//---------------------------------------------------------------------------//
/*
				Лабораторная работа № 20
учебной группы 61391
Волкова А.А.
Дата выполнения: 10.12.2018
Тема работы: «Разработка, отладка и испытание алгоритмов и программ нахождения максимальных потоков минимальной стоимости в графе».
Задание: Граф задан матрицей смежности стоимости доставки товара. Определить
минимальную стоимость доставки товара из точки s в точку t.
Номер матрицы соответствует вашему номеру по списку.
*/
//---------------------------------------------------------------------------//

// Структура метки для города
// @param from -  индекс соседнего города, из которого легче всего добраться
// @param value - стоимость пути до данного города из пункта отправления
typedef struct Town {
	int from;
	int value;
} Town;

// матрица смежности
int matrix[TOWNS][TOWNS] = {
	//      0   1   2   3   4   5   6   7   8   9  10  11  12 
	/*0*/ { 0,  0,  0,  0, 49, 30,  0, 35,  0,  0,  0, 31, 27},
	/*1*/ { 0,  0,  0, 18,  0,  0, 20,  0, 10,  0,  0, 17,  0},
    /*2*/ { 0,  0,  0,  0,  0,  0,  0,  0, 48,  0,  0,  1,  0},
	/*3*/ { 0,  0, 37,  0,  0, 37,  0,  0,  0, 13,  0,  0, 35},
	/*4*/ { 0,  0,  0, 28,  0,  0, 21, 48,  0,  0, 21, 40,  0},
	/*5*/ { 0, 24, 41,  5,  0,  0,  0,  0,  0, 32,  0,  0,  7},
	/*6*/ { 0,  0, 30, 45,  4,  0,  0,  0, 15, 41, 32,  0,  2},
	/*7*/ { 0, 34,  0,  0, 22,  0, 20,  0,  0, 37, 33, 10,  0},
	/*8*/ { 0,  0, 21,  0, 12, 22,  0, 28,  0,  0, 21,  0,  0},
	/*9*/ {41,  0, 17,  1,  0,  0, 13,  0,  0,  0, 18,  0, 29},
   /*10*/ {43,  0,  0,  0,  6, 38,  0, 33, 44, 49,  0, 22, 44},
   /*11*/ { 7,  0, 12, 31,  0, 33,  0, 48, 41,  0,  0,  0, 41},
   /*12*/ { 0,  0, 46, 42,  6, 29, 41,  3,  9,  0,  0, 26,  0}
};
Town*  towns;  // массив, хранящий расстояния до каждой вершины

// Функция заполнение исходных данных
void   fillTowns();
// Функция находжения пути с самой низкой стоимостью
void   findWay(int текущий_город, int конечный_пункт, _Bool* посещённые_города, int вес_пути_до_города);
// Возвращает ссылку на копию исходного массива
_Bool* copy(_Bool* исходный_массив);
// Выводит путь с самой низкой стоимостью
void   printWay(int начало_пути, int конец_пути);

void main() {
	setlocale(0, "Russian");
	int from, to;
	// Ввод индексов городов, между которыми будет находиться оптимальный маршрут
	printf("Введите пункт отправления:\n");
	scanf("%d", &from);
	printf("Введите конечный пункт:\n");
	scanf("%d", &to);
	// Заполнение массива towns первоначальными значениями
	fillTowns();
	// Заполнение массива towns значениями, учитывая маршрут
	findWay(from, to, (_Bool[]) { 0, 0, 0, 0, 0 }, 0);
	// Вывод маршрута с самой низкой стоимостью
	printWay(from, to);
	getch();
}
// Функция заполнение исходных данных
void fillTowns() {
	// Выделение памяти под массив, где будет хранится информация о путях до каждой из вершин
	towns = malloc(sizeof(Town) * TOWNS);
	// Заполнение массива
	for (int i = 0; i < TOWNS; i++) {
		// Это значит, что стоимость пути из исходного города в город с индексом i равна 1000 (∞),
        // а добраться можно через город -1 
		towns[i] = (Town) { -1, 1000 };
	}

}
// Возвращает ссылку на копию исходного массива
_Bool* copy(_Bool* parent) {
	_Bool* c = malloc(TOWNS);
	for (int i = 0; i < TOWNS; i++)
		c[i] = parent[i];
	return c;
}
// Функция находжения самого длинного пути 
void findWay(int from, int to, _Bool* visited, int value) {
	// Помечение вершины как посещённой
	visited[from] = true;
	// Обход всех вершин
	for (int i = 0; i < TOWNS; i++) {
		// Если имеется связь с текущей вершиной и вершина ещё не посещялась
		if (matrix[from][i] && !visited[i]) {
			// то увеличиваем длину пути на вес ребра
			int newValue = value + matrix[from][i];
			// Если данный путь длиннее, чем все предыдущие
			if (towns[i].value > newValue) {
				// то обновляем информацию о вершине 
				towns[i].value = newValue;
				towns[i].from = from;
				// Если не достигнута конечная вершина
				if (to != i) {
					// то происходит вызов рекурсии
					findWay(i, to, copy(visited), newValue);
				}
			}
		}
	}
}
// Выводит самый длинный маршрут
void printWay(int from, int to) {
	if (towns[to].from == -1) { // Если конечный пункт так и не изменил своего первоначального значения
		printf("\nНевозможно найти маршрут из города %d в город %d:\n", from, to);
		return;
	}
	printf("\nСамый дешёвый маршрут из города %d в город %d:\nконец <<= ", from, to);
	do {
		printf("город %d [стоимость %d] <<= ", to, towns[to].value);
		to = towns[to].from;
	} while (towns[to].from != -1);
	printf("город %d <<= начало", to);
}
