#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf
#define TOWNS   5
#define true	1

#include <stdio.h>
#include <malloc.h>

//---------------------------------------------------------------------------//
/*
				Лабораторная работа № 21
учебной группы 61391
Волкова А.А.
Дата выполнения: 11.12.2018
Тема работы: «Разработка, отладка и испытание алгоритмов и программ методом ветвей и границ».
Задание: Решите задачу из лабораторной работы № 20 методом ветвей и границ.
Вариант соответствует вашему номеру по списку.
Граф задан матрицей смежности стоимости доставки товара. Определить
минимальную стоимость доставки товара из точки s в точку t.
Номер матрицы соответствует вашему номеру по списку.
*/
//---------------------------------------------------------------------------//

//
typedef struct Town {
	int from;
	int value;
} Town;

//
int matrix[TOWNS][TOWNS] = {
	//     0  1  2  3  4
	/*0*/{ 0, 50, 0, 0, 0 },
	/*1*/{ 0, 0, 10, 15, 0 },
	/*2*/{ 0, 0, 0, 0, 20 },
	/*3*/{ 0, 0, 10, 0, 5 },
	/*4*/{ 0, 0, 0, 0, 0 }
};
Town*  towns;  // массив, хранящий расстояния до каждой вершины

// Функция заполнение исходных данных
void   fillTowns();
// Функция находжения пути с самой низкой стоимостью
void   findWay(int текущий_город, int конечный_пункт, _Bool* посещённые_города, int вес_пути_до_города);
// Возвращает ссылку на копию исходного массива
_Bool* copy(_Bool* исходный_массив);
// Выводит путь с самой низкой стоимостью
void   printWay(int начало_пути, int конец_пути);


void main() {
	setlocale(0, "Russian");
	fillTowns();
	findWay(0, 4, (_Bool[]) { 0, 0, 0, 0, 0 }, 0);
	printWay(0, 4);
	getch();
}
// Функция заполнение исходных данных
void fillTowns() {
	// Выделение памяти под массив, где будет хранится информация о путях до каждой из вершин
	towns = malloc(sizeof(Town) * TOWNS);
	// Заполнение массива
	for (int i = 0; i < TOWNS; i++) {
		towns[i] = (Town) { -1, 1000 };
	}

}
// Возвращает ссылку на копию исходного массива
_Bool* copy(_Bool* parent) {
	_Bool* c = malloc(TOWNS);
	for (int i = 0; i < TOWNS; i++)
		c[i] = parent[i];
	return c;
}
// Функция находжения самого длинного пути 
void findWay(int from, int to, _Bool* visited, int value) {
	// Помечение вершины как посещённой
	visited[from] = true;
	// Обход всех вершин
	for (int i = 0; i < TOWNS; i++) {
		// Если имеется связь с текущей вершиной и вершина ещё не посещялась
		if (matrix[from][i] && !visited[i]) {
			// то увеличиваем длину пути на вес ребра
			value += matrix[from][i];
			// Если данный путь длиннее, чем все предыдущие
			if (towns[i].value > value) {
				// то обновляем информацию о вершине 
				towns[i].value = value;
				towns[i].from = from;
				// Если не достигнута конечная вершина
				if (to != i) {
					// то происходит вызов рекурсии
					findWay(i, to, copy(visited), value);
				}
			}
			value -= matrix[from][i];
		}
	}
}
// Выводит самый длинный маршрут
void printWay(int from, int to) {
	printf("\nСамый длинный маршрут из города %d в город %d:\n", from, to);
	do {
		printf("%d<= ", to);
		to = towns[to].from;
	} while (towns[to].from != NULL);
	printf("%d<= %d", to, from);
}
