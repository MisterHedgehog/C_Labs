#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf
#define SERVERS   13

#include <stdio.h>

//---------------------------------------------------------------------------//
/*
				Лабораторная работа № 19
учебной группы 61391
Волкова А.А.
Дата выполнения: 09.12.2018
Тема работы: «Разработка, отладка и испытание алгоритмов и программ нахождения максимальных потоков в графе».
Задание: Пропускные способности дуг заданы матрицей. Построить максимальный
поток от s к t и указать минимальный разрез, отделяющий s от t .
Номер матрицы соответствует вашему номеру по списку.
*/
//---------------------------------------------------------------------------//

// Структура вершины
typedef struct Server {
	struct Server* from;
	int number;
} Server;

// матрица смежности
int N[SERVERS][SERVERS] = {
	//     0   1   2   3   4   5   6   7   8   9  10  11  12
	/*0*/{ 0,  6, 42, 14,  0, 16,  0, 36,  0,  0,  5,  0,  0},
	/*1*/{ 0,  0,  0,  3, 27, 12,  0, 45,  0, 23,  2,  0,  0},
	/*2*/{ 0, 21,  0, 21, 25,  0,  0,  0, 29,  0, 13,  9,  0},
	/*3*/{ 0, 32, 31,  0,  0,  0, 30,  0, 31,  0, 27,  0,  0},
	/*4*/{ 0,  0,  0,  0,  0, 21,  0,  2, 22, 44, 44, 41, 33},
	/*5*/{35,  0,  0,  2,  8,  0,  0, 29,  5,  0, 42,  0,  0},
	/*6*/{ 0, 11,  0, 48,  0,  0,  0,  0, 42,  0,  0,  0, 45},
	/*7*/{ 0,  0, 29,  0,  0, 48,  1,  0,  0, 41,  0,  0, 34},
	/*8*/{24, 16,  7,  0,  0,  0,  0, 21,  0,  8,  0, 23, 47},
	/*9*/{ 0, 31, 44,  0,  0, 41,  0,  0, 24,  0,  0,  0,  0},
   /*10*/{12, 25,  0,  0,  7,  0,  0, 39,  0,  0,  0,  0,  0},
   /*11*/{ 0,  0, 25, 30,  0, 17,  0,  0,  0, 47,  4,  0,  0},
   /*12*/{38,  0,  0, 35,  6,  0,  3,  0,  0, 36, 14,  0,  0},
};
int threads = 0; // количество потоков
int stream  = 0; // максимальный поток

// Функция определение кратчайшего потока
void findThread(int текущий_сервер, int конечный_сервер, Server посещённые_сервера, int вес_потока_до_сервера);
// Функция вывода потока
printThread(Server конец_потока, int пропускная_способность);

void main() {
	setlocale(0, "Russian");
	int from, to;
	// Ввод индексов серверов, между которыми будут передоваться пакеты данных
	printf("Введите пункт отправления:\n");
	scanf("%d", &from);
	printf("Введите конечный пункт:\n");
	scanf("%d", &to);
	// Определение кратчайшего пути
	findThread(from, to, (Server) {NULL, from}, 1024);
	printf("\nМаксимальная пропускная способность %d бит", stream);
	getch();
}
// Функция определение кратчайшего потока
void findThread(int from, int to, Server visited, int value) {
	for (int i = 0; i < SERVERS; i++) { // Обход вершин
		Server * v = &visited; 
		_Bool was = 0;
		while (v != NULL && !was) {
			// Если данная вершина присутствует в потоке, то отмечаем этот факт
			if (v->number == i) was = 1;
			v = v->from;
		}
		int bits = N[from][i];
		if (bits && !was) { // Если есть связь между вершинами и вершина ещё не посещалась
							// Создание следующего сервера, который ссылается на данный
			Server server = {&visited, i};
			// Нахождение минимального разреза
			int minValue = value > bits ? bits : value; 
			if (i == to) { // Если найден конечный сервер
				           // Вывод потока 
				printThread(server, minValue);
			} else // Если не найден конечный сервер
				   // Поиск конечного сервера
			findThread(i, to, server, minValue);
		}
	}
}
// Функция вывода потока, необходимо передать value (значение, которое будет отниматься от напечатоного потока)
printThread(Server town, int value) {
	Server bigin = town;				//  Буфферная переменная
	int startEdge = town.number;		//  Начальная и конечная вершина
	int finishEdge = town.from->number; //  тончайшей дуги потока
	for (; bigin.from != NULL; bigin = *bigin.from) {
		if ((N[bigin.from->number][bigin.number] < value)) {
			// Нахождение пропускной способности минимального разреза
			value = N[bigin.from->number][bigin.number];
		}
	}
	if (value) { // Если поток существует
		printf("Поток %d: (%d)", ++threads, town.number);
		for (; town.from != NULL; town = *town.from) {
			printf(" <<= %d битов свободно <<= (%d)", N[town.from->number][town.number], town.from->number);
			if (!(N[town.from->number][town.number] -= value)) {
				// Нахождение минимального разреза
				int startEdge = town.number;
				int finishEdge = town.from->number;
			}
		}
		printf("\n Данный поток ограничен дугой (%d =>> %d) c пропускной способностью дуги %d бит\n\n", finishEdge, startEdge, value);
		// Дабавление пропускной способности потока к максимальному для будущего вывода
		stream += value;
	}
}