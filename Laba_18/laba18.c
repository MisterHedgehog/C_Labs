#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf
#define TOWNS 31
#define true 1
#define INFINITY 1000

#include <stdio.h>

//---------------------------------------------------------------------------//
/*
				Лабораторная работа № 18
учебной группы 61391
Волкова А.А.
Дата выполнения: 09.12.2018
Тема работы: «Разработка, отладка и испытание алгоритмов и программ поиска кратчайших расстояний».
Задание: В предложенном графе найти кратчайшие пути от начальной вершины ко
всем остальным, одним из известных алгоритмов. Номер начальной вершины
соответствует вашему номеру по списку. 
*/
//---------------------------------------------------------------------------//

// матрица смежности
const int N[TOWNS][TOWNS] = { 
	//     0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
	/*0*/{ 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	/*1*/{ 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	/*2*/{ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0},
	/*3*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0},
	/*4*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0},
	/*5*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	/*6*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	/*7*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	/*8*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	/*9*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*10*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 0, 0, 0, 0},
   /*11*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*12*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*13*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0},
   /*14*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*15*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0},
   /*16*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*17*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*18*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*19*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0},
   /*20*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0},
   /*21*/{ 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0},
   /*22*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0},
   /*23*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*24*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0},
   /*25*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*26*/{ 0, 0, 6, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*27*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0},
   /*28*/{ 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0},
   /*29*/{ 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   /*30*/{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};
int result[TOWNS];  // Массив, содержащий единицы и нули для каждой вершины,
			        // result[i]=0 - еще не найден кратчайший путь в i-ю вершину,
			        // result[i]=1 - кратчайший путь в i-ю вершину уже найден
int way[TOWNS];     // way[i] - длина кратчайшего пути из вершины s в i
int previos[TOWNS]; // previos[i] - вершина, предшествующая i-й вершине
			        // на кратчайшем пути
int p = TOWNS;	    // Количество вершин в графе
int u;		        // Счетчик вершин
					// Будем искать путь из вершины s в вершину g
int s = 15;          // Номер исходной вершины
int g;              // Номер конечной вершины
int v;				// Текущая вершина

void main() {
	// Добавление кириллицы в консоль
	setlocale(0, "Russian");
	// Обход всех вершин
	for (g = 0; g < TOWNS; g++) {
		resetData();
		while (true)
		{
			// Перебор всех вершин, смежные v, и поиск для них кратчайший путь
			for (u = 0; u < p; u++)
			{
				if (N[v][u] == 0) continue; // Вершины u и v несмежные
				if (result[u] == 0 && way[u] > way[v] + N[v][u]) // Если для вершины u еще не найден кратчайший путь 
					                                             // и новый путь в u короче чем старый, то
				{
					way[u] = way[v] + N[v][u];	// сохранение более короткую длину пути в массив way и
					previos[u] = v;	            // сохранение, что v->u часть кратчайшего пути из s->u
				}
			}
			// Поиск из всех длин некратчайших путей самый короткий
			int w = INFINITY;       // Для поиска самого короткого пути
			v = -1;                 // В конце поиска v - вершина, в которую будет найден новый кратчайший путь. Она станет текущей вершиной
			for (u = 0; u < p; u++) // Перебор всех вершин
			{
				if (result[u] == 0 && way[u] < w) 
		        // Если для вершины не найден кратчайший путь и если длина пути в вершину u меньше уже найденной, то
				{
					v = u; // текущей вершиной становится u-я вершина
					w = way[u];
				}
			}
			if (v == -1)
			{
				printf("Нет пути из вершины %d в вершину %d.\n", s, g);
				break;
			}
			if (v == g){ // Найден кратчайший путь, вывод его
				printf("Кратчайший путь из вершины %d в вершину %d:\n", s, g);
				u = g;
				while (u != s){
					printf(" %d", u);
					u = previos[u];
				}
				printf(" %d. Длина пути - %d\n", s, way[g]);
				break;
			}
			result[v] = 1;
		}
	}
	getch();
}

resetData() {
	// Инициализация начальных значений массивов
	for (u = 0; u < p; u++)
	{
		way[u] = INFINITY;    //Сначала все кратчайшие пути из s в i равны бесконечности
		result[u] = 0;        // и нет кратчайшего пути ни для одной вершины
	}
	previos[s] = 0; // s - начало пути, поэтому этой вершине ничего не предшествует
	way[s] = 0;     // Кратчайший путь из s в s равен 0
	result[s] = 1;  // Для вершины s найден кратчайший путь
	v = s;          // Делаем s текущей вершиной
}

/*---------------------------------------------------------------------------//
В данной программе применяется алгоритм Дейкстра. Код является модификацией,
скопированной с сайта.
Поиск кратчайшего пути в графе.[Электронный ресурс] Режим доступа - www.cyberforum.ru/cpp-beginners/thread410213.html. 
Дата доступа - 10.12.2018
//---------------------------------------------------------------------------*/
